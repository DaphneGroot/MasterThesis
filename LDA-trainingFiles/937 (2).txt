Programmeertaal.
Syntaxkleuring wordt vaak gebruikt om de programmeurs te helpen bij het herkennen van de onderdelen van de broncode. De getoonde taal is Python.
Een programmeertaal is een formele taal waarin de opdrachten die een computer moet uitvoeren, worden geschreven. Deze talen hebben een andere syntaxis en grammatica dan natuurlijke talen. Deze laatste zijn te complex en ambigu om als programmeertaal te fungeren. Code die in een programmeertaal geschreven is, dient maar op één manier te kunnen worden 'begrepen' door de computer.
Programmeerparadigma.
Er zijn in de loop der jaren duizenden programmeertalen ontstaan en zij kunnen op verschillende manieren gecategoriseerd worden. Een veel gebruikt onderscheid is dat van programmeerparadigma. Enkele belangrijke voorbeelden zijn de imperatieve, functionele en logische programmeerparadigma's, waarbij vermeld moet worden dat programmeertalen soms meerdere paradigma's combineren.
Gebruik.
Hiervan bestaan allerlei tussenvormen en varianten.
Een "hogere" (d.w.z. gecompileerde of geïnterpreteerde) programmeertaal is ontworpen om de programmeur zo helder en elegant mogelijk te laten specificeren wat een programma moet doen in de termen waarin de programmeur over het probleem nadenkt, zonder detailkennis over hoe het precies door de computer uitgevoerd gaat worden: zulke talen bieden abstracties op hoog niveau en zijn machine-onafhankelijk. In assembleertaal wordt alleen geprogrammeerd als er specifieke kennis over de precieze werking van de computer in kwestie gebruikt moet worden, bijvoorbeeld omdat het programma anders te veel ruimte of tijd zou gebruiken.
Is er sprake van compilatie, dan is vaak een onderscheid nodig tussen handelingen verricht tijdens het bewerken van de broncode ('at edit time'), tijdens het vertaalproces van broncode naar doelcode ('at compile time'), en tijdens het uitvoeren van de doelcode ('at run time'). In elk van deze fasen kan software de programmeur ondersteunen, bijvoorbeeld door de geldigheid of zinnigheid van bepaalde bewerkingen of uitdrukkingen te controleren.
Tijdens het vertalen vindt vaak optimalisatie van de code plaats. Een simpel voorbeeld: als tijdens het vertalen blijkt dat er in de doelcode een optelling of aftrekking met 0 ontstaat, kan die worden weggelaten.
Een programma dat met een compiler vertaald is naar doelcode, kan over het algemeen — mede door optimalisatie — sneller door de computer worden uitgevoerd, dan wanneer gebruikgemaakt wordt van een interpreter, omdat de laatste de opdrachten altijd eerst nog moet omzetten naar machinetaal - het equivalent van de compilatie wordt in run-time gedaan. Veel talen werken echter met een tussenvorm, waarin op het moment dat opdracht tot uitvoering van een programma wordt gegeven, alsnog een compilatie naar tussencode en/of doelcode wordt gedaan: Just-In-Time-compilatie.
Het traditionele onderscheid tussen gecompileerde talen enerzijds en geïnterpreteerde talen (of 'scripttalen') is daarom niet helemaal juist. Is een geïnterpreteerde programmeertaal populair, dan worden er vaak compilers (JIT of anderszins) voor geschreven om de uitvoering te versnellen; ook komt het wel voor dat er een interpreter wordt geschreven voor een tot dan toe alleen gecompileerde taal, of een vertaler van de ene programmeertaal naar de andere.
Definitie.
Onder programmeertalen worden, in de normaal gebruikte definitie, talen verstaan die turingvolledig zijn. Dat wil zeggen dat het mogelijk moet zijn om in de programmeertaal een interpreter voor een Turingmachine te schrijven, en dat het mogelijk moet zijn een interpreter te schrijven voor de programmeertaal op een Turingmachine.
In een taal die niet Turingvolledig is, kan een kleiner aantal problemen opgelost worden dan in een Turingvolledige taal. In SQL kan men bijvoorbeeld wel totalen van tabellen met gegevens berekenen, maar men kan niet berekenen wat de kortste route tussen twee punten in een graaf is.
Geschiedenis.
Enkele van de vele boeken over programmeertalen
Het is mogelijk om computers direct in hun eigen machinetaal te programmeren: direct de enen en nullen te specificeren die door de processor kunnen worden begrepen. Dit was voor de eerste computers gebruikelijk, met schakelaartjes werden groepen van 8 bits ingesteld. Men ondervond echter snel dat het veel te lastig was om programma's die op die manier waren "geschreven", te onderhouden. Snel werd er daarom een symbolische manier bedacht om de machine-instructies als tekst weer te geven in de vorm van mnemonics. Zo werd het mogelijk om instructies veel eenvoudiger te lezen. Zulke code, die grotendeels een-op-een met de instructiecodes overeenkomt, noemt men "assembly-code" of ook wel "assembler" en is geschreven in assembleertaal. Een programma dat deze code in machinetaal omzet wordt een "assembler" genoemd.
Voor het programmeren van assembler en machinetaal moet de programmeur veel weten van de computer die hij wil programmeren. Om programmeren makkelijker te maken, zijn daarna andere programmeertalen, de zogenaamde "hogere programmeertalen" ontwikkeld. Hoe hoger de orde, hoe verder de taal van de machine-instructies af staat. Een imperatieve programmeertaal (zoals Pascal of C) staat bijvoorbeeld dichter bij de machine-instructies dan een functionele programmeertaal (zoals Scheme en Haskell). Een functionele programmeertaal sluit meer aan bij het denken van de mens dan bij de interne werking van de computer. Zo is het in Haskell mogelijk om 'normale' wiskundige definities te gebruiken.
De generaties worden vaak afgekort als GL, bijvoorbeeld 3GL, als afkorting van 3rd Generation Language(s).
Een van de eerste hogere programmeertalen was Plankalkül, in 1946 ontwikkeld door de Duitser Konrad Zuse.
Om programmeertalen te beschrijven, is een metataal bedacht: BNF of "Backus Naur Form". Deze beschrijft alleen de vorm (syntaxis) van in de taal geschreven programma's, niet hun betekenis (semantiek).
Voor veel programmeertalen kan de programmeur gebruikmaken van een software-ontwikkelomgeving die speciaal is toegerust om de ontwikkeling van programma's in die taal te ondersteunen.

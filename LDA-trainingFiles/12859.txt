RSA (cryptografie).
RSA is een asymmetrisch encryptiealgoritme, dat veel gebruikt wordt voor elektronische handel (beveiliging van transacties en dergelijke). Het formele algoritme werd in 1977 ontworpen door Ron Rivest, Adi Shamir en Len Adleman (vandaar de afkorting RSA).
Clifford Cocks, een Britse wiskundige, die voor het Government Communications Headquarters (GCHQ) werkte, heeft in 1973 een gelijkwaardig algoritme beschreven in een intern document, dat pas in 1997 boven water is gekomen, omdat het als topgeheim geclassificeerd was.
De veiligheid van RSA steunt op het probleem van de ontbinding in factoren (bij heel grote getallen): op dit moment is het bijna onmogelijk de twee oorspronkelijke priemgetallen p en q te achterhalen als alleen p*q bekend is en p en q groot genoeg zijn; het zou te veel tijd in beslag nemen. Nieuwe ontwikkelingen op dit gebied zouden RSA onbruikbaar kunnen maken.
MIT heeft in 1983 in de V.S. het algoritme gepatenteerd. Het patent liep op 21 september 2000 af. Omdat het algoritme gepubliceerd werd vóór de patentaanvraag, kon het niet worden gepatenteerd in andere landen.
Sleutels.
"N" en "e" vormen de publieke sleutel, "N" en "d" vormen de geheime sleutel. Alleen "d" is dus geheim, want "N" is bekend. Alice stuurt "N" en "e" naar Bob via een mogelijkerwijs onveilig medium en ze houdt "d" geheim.
Versleutelen.
Dit kan snel gedaan worden door machtsverheffing door kwadrateren. Bob verzendt dan "c" naar Alice.
Ontsleutelen.
Merk op dat "c'd" = "n'ed". Als de complexiteit die het modulo rekenen met zich meebrengt even vergeten wordt, lijkt de ontsleutelingsrelatie triviaal. Immers dan leidt "ed" = 1 onmiddellijk tot "n'ed" = "n". Echter, niet-modulo rekenen met reële getallen geeft "d" = 1/"e" (niet geheim). De modulo vergelijking voor "d" daarentegen, "ed" ≡ 1 mod("p" − 1)("q" − 1), vraagt de waarden van "p" en "q" afzonderlijk. Zoals al in de inleiding is opgemerkt, zijn "p" en "q" zeer moeilijk uit "N" terug te rekenen en daarom geeft de modulo vergelijking een geheime waarde voor "d".
Het formele bewijs van de ontsleutelingsrelatie vraagt dus om bewerkingen modulo gehele getallen en is daarom niet triviaal — het wordt in de volgende sectie gegeven.
Als laatste stap verkrijgt Alice de boodschap "m" door op "n" het afgesproken protocol in omgekeerde richting toe te passen.
Bewijs ontsleutelingsrelatie.
voor zekere gehele "k". Dan, aannemend dat ggd("n", "p") = 1,
Als ggd("n", "p") ≠ 1 dan, omdat "p" priem is, geldt "n" ≡ 0 mod "p" en in totaal
Verder is "n'ed" − "n" = "sp" een veelvoud van "q". Omdat "p" geen veelvoud van q is moet "s" dit wel zijn,
"s" = "tq" voor zekere gehele "t", en dus geldt
en omdat "N" = "pq" en "n'ed" = "c"d is de ontsleutelingsrelatie bewezen.
Voorbeeld.
en we zijn inderdaad weer terug bij ASCII-code 100 (letter 'd').
Ondertekenen.
RSA kan ook worden gebruikt om een bericht te ondertekenen. Veronderstel dat Alice een ondertekend bericht wil zenden naar Bob. Ze berekent dan een hashwaarde uit het bericht, vercijfert die met haar geheime sleutel, en voegt dat als een "handtekening" bij het bericht. Deze handtekening kan alleen worden ontcijferd met haar publieke sleutel. Wanneer Bob het ondertekende bericht ontvangt, ontcijfert hij de handtekening met Alices publieke sleutel, en vergelijkt de aldus bekomen hashwaarde met de eigenlijke hashwaarde van het bericht. Als die gelijk zijn, weet hij dat de auteur van het bericht de geheime sleutel van Alice bezit (dus normaal gezien Alice is), en dat het bericht na verzending niet meer veranderd is.
Veiligheid.
Veronderstel dat Charlotte, een afluisteraar, de publieke sleutel "N" en "e", en de cijfertekst "c" onderschept. Ze kan niet rechtstreeks aan "d" geraken, omdat Alice dat geheim houdt. De meest voor de hand liggende manier voor Charlotte om "n" te vinden uit "c", is om "N" in de factoren "p" en "q" te ontbinden, zodat ze ("p"-1)*("q"-1) kan berekenen en "d" kan vinden uit "e". Er is nog geen polynomische-tijd methode gevonden om getallen in factoren te ontbinden met een gewone computer (de benodigde tijd wordt veel sneller groter dan bij lineair groter wordende getallen), maar het is niet bewezen dat er geen bestaat; zie priemfactor.
Het is ook niet bewezen dat de enige manier om "n" uit "c" te berekenen, is om "N" in factoren te ontbinden, maar er is nog geen gemakkelijkere manier ontdekt (tenminste geen publiekelijk bekende). Daarom wordt algemeen verondersteld dat Charlotte het bericht niet kan terugvinden als "N" groot genoeg is.
Als "N" 256 bits of korter is, kunnen de factoren in een paar uur gevonden worden met een personal computer, gebruik makende van software die vrij toegankelijk is op het internet. Als "N" 512 bits of korter is, kan, sinds 1999, de ontbinding uitgevoerd worden door enkele honderden computers (in een aanvaardbare tijd). Het is tegenwoordig aan te raden "N" ten minste 1024 bits lang te kiezen.
In 1994 heeft Peter Shor aangetoond dat een kwantumcomputer in principe de factorisatie in polynomiale tijd zal kunnen uitvoeren. Als (of wanneer) kwantumcomputers werkelijkheid worden, zal het algoritme van Shor RSA en andere soortgelijke algoritmes onbruikbaar maken. Als een efficiënte methode voor ontbinding in factoren met een gewone computer zou worden gevonden, of als een kwantumcomputer zou worden gemaakt, dan kunnen nog langere sleutels een tijdelijke oplossing bieden, maar zo'n veiligheidslek in RSA zou wel "retroactief" zijn: de publieke sleutel en de cijfertekst kunnen worden bijgehouden totdat het mogelijk wordt om het bericht te ontcijferen. Daarom is het niet veilig om lange-termijn geheimen uit te wisselen met RSA.
Sleutels.
Om de grote priemgetallen "p" en "q" te vinden worden meestal eerst willekeurige getallen van de juiste grootte gekozen. Die getallen worden dan getest met snelle methoden, die de meeste niet-priemgetallen uitsluiten. Als dan een "waarschijnlijk priemgetal" is gevonden, kan op een zekere (maar langzamere) manier worden nagegaan of het getal inderdaad priem is.
"p" en "q" mogen niet te dicht bij elkaar gelegen zijn, want anders zou de Fermatfactorisatie voor "N" succesvol kunnen zijn. Bovendien kan, als "p"-1 of "q"-1 enkel kleine priemfactoren hebben, "N" snel in factoren worden ontbonden, zodat deze waarden voor "p" en "q" ook moeten worden vermeden.
Er mag geen methode om priemfactoren te zoeken worden gebruikt, die een eventuele aanvaller enige informatie geeft over de priemgetallen. Een goede toevalsgenerator moet worden gebruikt. Coppersmith heeft in 1997 aangetoond dat als iemand de helft van de cijfers van "p" of "q" kan raden, hij gemakkelijk de andere helft kan berekenen.
Het is belangrijk dat de geheime sleutel "d" groot genoeg is. Wiener heeft in 1990 aangetoond dat als "p" tussen "q" en 2*"q" ligt (wat veel voorkomt) en "d" < "N"1/4/3, "d" op een efficiënte manier kan worden berekend uit "N" en "e".
Snelheid.
RSA is veel trager dan DES en andere symmetrische encryptiealgoritmes. In de praktijk vercijfert Bob gewoonlijk zijn bericht met een symmetrisch algoritme en de symmetrische sleutel (kort in vergelijking met het bericht) met RSA. Het symmetrisch vercijferd bericht en de met RSA vercijferde sleutel worden dan beiden verstuurd naar Alice.
Deze methode zorgt voor bijkomende veiligheidsmoeilijkheden. De methode voor symmetrische encryptie moet veilig zijn (niet gemakkelijk te kraken zonder de sleutel) en de symmetrische sleutel moet gemaakt worden met een goede toevalsgenerator, want anders zou Charlotte om RSA heen kunnen door de symmetrische sleutel te raden.
Sleutelverdeling.
Zoals bij alle encryptiemethoden, is het belangrijk hoe de publieke sleutels verspreid worden. We moeten ons bewust zijn van de mogelijkheid van een man-in-the-middle-aanval. Veronderstel dat Charlotte de communicatie tussen Alice en Bob kan onderscheppen. Ze ontvangt dan een publieke sleutel van Alice, maakt zelf een nieuwe publieke en geheime sleutel en stuurt haar eigen publieke sleutel naar Bob, die denkt dat hij de publieke sleutel van Alice ontvangt. Dan kan ze verdere berichten van Bob (vercijferd met haar publieke sleutel) ontvangen, ontcijferen met haar geheime sleutel, en (eventueel veranderd) weer geëncrypteerd met de eerder ontvangen publieke sleutel naar Alice sturen (Alice denkt dat het bericht rechtstreeks van Bob komt). In principe kunnen Alice en Bob niet merken dat Charlotte ertussen zit. Verdedigingen tegen zo'n aanval zijn meestal gebaseerd op digitale certificaten of andere onderdelen van een Public Key Infrastructure. Uiteraard is de beste oplossing dat Alice en Bob de sleutels (of een checksum) vergelijken tijdens een "echte" ontmoeting (als dat mogelijk is).
Tijdsgebaseerde aanvallen.
Kocher beschreef een ingenieuze nieuwe aanval op RSA in 1995: als Charlotte de hardware van Alice kent en de tijd nodig voor het ontcijferen van verschillende bekende cijferteksten kan meten, kan ze de geheime sleutel "d" snel vinden. Om deze aanval af te slaan, moet de decryptie in een constante tijd gebeuren, bekend onder de naam RSA blinding.
Aangepast gekozen cijfertekst aanvallen.
In 1996 beschreef Daniel Bleichenbacher de eerste praktische aangepast gekozen cijfertekst aanval tegen met RSA vercijferde berichten met de PKCS #1 v1 redundantiefunctie (een redundantiefunctie voegt structuur toe aan een RSA-bericht, zodat het mogelijk is om te weten of een gedecrypteerd bericht goed is). Omwille van zwakke plekken in het PKCS #1 schema kon Bleichenbacher een aanval tegen de RSA-implementatie van het SSL protocol opzetten, en mogelijk de sessie-sleutels te weten komen. Daarom raden cryptografen nu aan om bewijsbaar veilige redundantietesten zoals OAEP te gebruiken, en RSA Laboratories heeft nieuwe versies van PKCS #1 vrijgegeven, die niet gevoelig zijn voor deze aanvallen.

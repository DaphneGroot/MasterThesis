X86-instructieset.
De x86-instructieset is een instructieset voor computers. Deze werd eind jaren zeventig door Intel ontwikkeld voor de 8086-processor. IBM besloot de processor van Intel in zijn IBM PC te gebruiken, en doordat de pc wijdverbreid raakte, werd de x86-instructieset met voorsprong de meest gebruikte instructieset.
De x86-instructieset was oorspronkelijk een 16 bits-instructieset. In de loop der jaren is de x86-instructieset steeds uitgebreid om aan de wensen van de tijd te blijven voldoen. Belangrijke wijzigingen waren een 32 bits-modus, toevoeging van vectorregisters (MMX en SSE) en recent de toevoeging van een 64 bits-modus: x86-64 (AMD64, EM64T).
Gegevens van de instructieset.
Er zijn drie hoofdvarianten van de x86-instructieset, de 16 bits-variant, de 32 bits-variant en de 64 bits-variant. Afhankelijk van de modus waarin een x86-processor gezet wordt, gebruikt de processor een van de varianten.
Fabrikanten.
Aanvankelijk werden x86-processoren alleen door Intel gefabriceerd, hoewel NEC wel de V20- en V30-processoren met 8088-compatibele instructieset leverde. In de tijd van de 80386-processor besloot Intel zijn ontwerp aan andere fabrikanten in licentie te geven. Deze fabrikanten, AMD en Cyrix, konden vervolgens zelfstandig hun eigen x86-processoren op de markt brengen.
Toen de 80486 enige tijd op de markt was, leek het er op dat Intel spijt kreeg van zijn besluit zijn processoren in licentie te geven. Nieuwe licenties werden stopgezet en er ontbrandde een jarenlange rechtsstrijd tegen AMD over de auteursrechten op delen van de processor. Deze rechtszaak werd uiteindelijk geschikt, waarbij AMD het recht kreeg x86-processoren te maken, maar zij deze vanaf dan zelf diende te ontwerpen. Sindsdien ontwierpen zowel Cyrix als AMD hun eigen processoren.
Last uit het verleden.
De x86-architectuur gaat al lang mee. Sinds eind jaren 70 is er veel aan inzicht veranderd in hoe processoren het best gebouwd kunnen worden, en er zijn steeds meer instructies bij gekomen waarvan sommige oude overbodig maken, en andere omslachtig geïmplementeerd zijn omdat het anders onmogelijk was ze in de bestaande instructieset in te passen. Velen vinden de x86-instructieset daarom onelegant.
De reden dat we deze instructieset vandaag de dag nog steeds gebruiken, is dat er heel veel software voor de x86-instructieset geschreven is, zodat het ondoenlijk is geworden de hele wereld op een andere instructieset over te laten gaan.
Zoiets is in het verleden een aantal keren geprobeerd. De bekendste voorbeelden hiervan zijn de instructiesets van de PowerPC en de Itanium. De ontwikkeling had maar één enkel doel: een door moderne technieken ontwikkelde processor zou dusdanig veel krachtiger worden dan een willekeurige x86-processor dat deze het op den duur zou verliezen.
Dit is echter niet gebeurd. De achterliggende reden is dat ook de ideeën achter de PowerPC ietwat achterhaald raakten, en alhoewel de processor als minder "lelijk" beschouwd wordt dan de x86-processoren, dragen beide inmiddels een last uit het verleden mee. Een ietwat praktischere reden was dat de PowerPC nooit veel voordeel gaf om de x86-processoren te kunnen verdringen, en op bepaalde momenten zelfs iets achterliep.
Tabel van de instructieset.
In veel instructies wordt het deel "reg", bits 5 4 3, gebruikt om de opcode uit te breiden.
In onderstaande tabellen leest u in de linkerkolom de bits 7-3 van de opcode, de eerste byte van de eerste instructie. Bovenaan staan de bits 2-0. Voor de instructies waarbij het deel "reg" van de mod/rm-byte wordt gebruikt om de opcode uit te breiden, vindt u deze waarde in de kolom "reg".
Een speciaal geval is de instructie POP CS, met de opcode 0F. Deze instructie wordt als volkomen nutteloos beschouwd. In de latere versies van de processor werd deze instructie dan ook verwijderd en ging 0F dienen om een opcode van twee bytes aan te kondigen. De instructies die met 0F beginnen vindt u in de tweede tabel.
De operanden kunnen een lengte hebben van 8 of 16 bits, met ingang van de 80386 ook 32 bits. Bij veel instructies wordt de lengte van de operand bepaald door bit 0 van de opcode: is deze nul, dan heeft de operand 8 bits. Is deze niet nul, dan bepaalt de instelling van de processor wat de operandlengte is (16 of 32). Deze kan worden veranderd met het prefix 66.
De volledige instructieset staat in de tabellen hieronder

Reduced instruction set computer.
Een Reduced instruction set computer, acroniem RISC is een processor die werkt met een kleine set simpele basisinstructies. Dit in tegenstelling tot Complex instruction set computers (CISC), die werken met een relatief omvangrijke set complexe instructies.
Vergelijking CISC-RISC.
De RISC-processor heeft minder schakelingen dan een CISC-processor en is daardoor eenvoudiger te maken en verder te miniaturiseren. Dit wordt bereikt door de kleinere instructieset, eenvoudiger gecodeerde instructies en door het ontbreken van microcode. Wegens de kleinere instructieset moet de RISC-processor voor dezelfde opdracht meer instructies uitvoeren dan een CISC-processor. Dit kan echter gecompenseerd worden door een hogere verwerkingssnelheid. In de praktijk ontlopen de twee ontwerpprincipes elkaar niet veel in verwerkingssnelheid. Het belangrijkste verschil is het energieverbruik: RISC processoren zijn zuiniger.
Na de uitvinding van RISC, werd aanvankelijk wel gedacht dat CISC geen lang leven meer beschoren zou zijn. Maar doordat CISC-processoren complexer zijn, blijken er ook meer ontwerptrucs mogelijk. De ontwerp- en bouwkosten zijn hierdoor wel hoger, maar dat is bij zeer grote oplages overkomelijk.
Voorbeelden van RISC-processors zijn de PowerPC van IBM, de UltraSPARC van Sun Microsystems en de AVR core van ATMEL. Een processor waarin het principe zeer zuiver toegepast wordt is de ARM van ARM Ltd.
Kenmerken.
De centrale filosofie van het RISC-ontwerp is dat instructies zo snel mogelijk uitgevoerd moeten worden door de CPU. Dat betekent onder andere dat er minder instructies zijn, en dat deze eenvoudiger zijn. Dat betekent ook dat er meer instructies nodig zijn om hetzelfde resultaat te verkrijgen in vergelijking met CISC-machines. Dit wordt echter gecompenseerd door de snelheid waarmee de individuele instructies worden uitgevoerd.
Load/store-architectuur.
Alleen zogenaamde Load- en store-opdrachten adresseren het geheugen; alle andere opdrachten werken met interne registers op de processor.
Pipelining.
Een processor met pipelining is verdeeld in een aantal onafhankelijke eenheden met elk een eigen taak, zoals het ophalen van instructies, het decoderen van instructies en het uitvoeren van instructies. Deze eenheden werken parallel op verschillende instructies. Terwijl de eerste instructie uitgevoerd wordt door één eenheid, wordt de tweede gedecodeerd door een andere eenheid en de derde uit het geheugen opgehaald door nog een andere eenheid.
Door het aanspreken van het geheugen onder te brengen in een aparte eenheid kan het probleem dat een Load- of Store-opdracht langzamer is dan andere instructies worden opgelost. Terwijl de Load/Store-instructie nog wordt behandeld door de eenheid die geheugentoegang uitvoert kan de volgende instructie al worden uitgevoerd door de uitvoereenheid. Er wordt dus niet gewacht tot de geheugenaanroep klaar is.
Een voorwaarde is hierbij wel dat de instructie die op een geheugeninstructie volgt het register waarop de geheugeninstructie werkt niet gebruikt. Het is de taak van de compiler om te zorgen dat aan deze voorwaarde wordt voldaan.
Dit is ook een voorbeeld van een algemene trend in RISC-ontwerpen: de complexiteit wordt uit de hardware (de processor) naar de software (de compiler) verplaatst.
Geen microcode.
De machinetaal-instructies die door een compiler worden gegenereerd, worden op een RISC-machine direct door de hardware uitgevoerd en niet, zoals bij traditionele CISC-machines, door microcode geïnterpreteerd.
Dit is mogelijk doordat een RISC een beperkt aantal instructies heeft, die allemaal eenvoudige bewerkingen uitvoeren en eenvoudig gecodeerd zijn. Het uitvoeren van instructies direct door de hardware is natuurlijk altijd sneller, maar hier kan bij CISC-machines geen gebruik van worden gemaakt door hun instructieset. Omdat CISC-machines zoveel verschillende instructies hebben, waarvan sommigen relatief complex zijn, is het praktisch niet mogelijk om de uitvoer ervan in de hardware van de processor te implementeren: daarvoor is geen ruimte op de chip en de chip zou te duur worden.
Kleine, homogene instructieset.
Omdat RISC-processors geen microcode gebruiken is hun mogelijkheid om instructies te decoderen beperkt. Daarom is hun instructieset homogeen: alle instructies zijn even lang en hebben dezelfde structuur (of er zijn een klein aantal soorten instructies). Dit wil zeggen dat bijvoorbeeld het eerste argument van een instructie altijd op dezelfde positie zit, bijvoorbeeld bits 6 t/m 11. Hetzelfde voor het tweede argument, enzovoort.
Hoewel dit betekent dat sommige instructies onnodig lang zijn, kost het decoderen van instructies minder tijd, en is het decoderingscircuit op de chip eenvoudiger (en dus kleiner).
Grote, homogene registerset.
RISC-machines hebben een groot aantal registers. Dit is min of meer noodzakelijk om het aantal Load/Store-instructies zo klein mogelijk te houden: behalve de Load/Store-instructies werken alle andere instructies immers alleen op registers.
Verder is de registerset in een RISC-machine over het algemeen homogeen: er zijn weinig of geen speciale registers. Veel CISC-machines hebben speciale registers voor de stackpointer, voor de basepointer, voor indexering, voor geheugentransfers, enzovoort (op de x86 respectievelijk de SP, BP, CX en SI/DI). Omdat RISC-processors minder (of geen) speciale registers hebben, heeft de compiler meer vrijheid bij de registerallocatie, wat het aantal geheugenverwijzingen weer kan verminderen.
Ook hebben sommige RISC-processors (zoals de SPARC) meerdere registersets. Dit maakt het mogelijk om functionaliteit waarvoor normaal de stack (in het langzame geheugen) gebruikt wordt nu enkel met (snelle) registers uit te voeren. Eigenlijk wordt de stack gesimuleerd in het registergeheugen waarbij een stackframe niet uit een aantal geheugencellen bestaat, maar uit een aantal registers. Dit kan leiden tot een behoorlijke snelheidswinst.
Geïntegreerd cachegeheugen.
Instructies die op het geheugen werken zijn langzaam, omdat het geheugen langzaam is en ook omdat processor en geheugen gescheiden zijn door een bus. Om dit op te lossen werd op een gegeven moment een zogenaamde Level2-cache geïntroduceerd. Hoewel deze een behoorlijke snelheidswinst oplevert, is hij nog steeds te langzaam om een optimale RISC-architectuur te realiseren. Daarom gebruikt men in RISC-machines meestal ook nog een geïntegreerde cache (ook wel "on-chip cache" genoemd). Deze bevindt zich op de processor zelf. Deze geïntegreerde cache wordt vervolgens meestal opgedeeld in een instructie-cache en een data-cache.
RISC en CISC: Intel x86 processoren.
De bovengenoemde kenmerken zijn niet noodzakelijk uniek voor RISC-machines. Ze worden ook in CISC-machines toegepast om verbeteringen te krijgen. Een voorbeeld hiervan is zijn de Intel x86-processoren.
Beginnend met de i486 is Intel tot op heden bezig geweest om RISC-concepten te introduceren in haar x86 processors. Zo zijn sommige veelgebruikte instructies (zoals MOV) bij de i486 in de hardware geïmplementeerd, en worden alleen de complexere opdrachten door microcode uitgevoerd. Vaak gebruiken compilers voor x86-processoren deze complexe opdrachten helemaal niet, maar beperken ze zich tot de eenvoudige opdrachten die niet alleen sneller zijn omdat ze direct door de hardware uitgevoerd worden maar die zich ook beter lenen voor pipelining.
De x86 heeft al sinds de i286 een zekere mate van pipelining, en de i486 heeft inmiddels een 5-traps pipeline. Ook heeft de i486 een cache-geheugen van 8 kilobyte dat geïntegreerd is in de processor.
